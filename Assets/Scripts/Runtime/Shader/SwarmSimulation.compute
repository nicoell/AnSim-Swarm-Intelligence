//Kernels with Definitions to allow different compilation per Kernel
#pragma kernel MaskedReset SETUP_ONLY
#pragma kernel SlaveUpdate SLAVE_SIM SLAVE_OR_MASTER
#pragma kernel MasterUpdate MASTER_SIM SLAVE_OR_MASTER

// Macro for HLSL Tools only for Visual Studio
// Prevents graying out unknown preprocessor macros
#if defined(__INTELLISENSE__)
  #define SETUP_ONLY
  #define SLAVE_SIM 
  #define MASTER_SIM
  #define SLAVE_OR_MASTER
#endif

#define SWARM_SIZE 64
#define MAX_HEALTH 1

#include "Definitions/Structs.hlsl"
#include "Utils/Random.hlsl"
#include "Definitions/SharedInputs.hlsl"
#include "Definitions/SimulationInputs.hlsl"

StructuredBuffer<uint> SwarmIndexBuffer;
RWStructuredBuffer<SwarmData> SwarmBuffer;
RWStructuredBuffer<SwarmParticleData> SwarmParticleBuffer;

// Shared Memory
groupshared float4 gsLocalBestAndFitness[SWARM_SIZE];    
uint GetGSLocalBestIndex()
{
  uint indexToBest = 0;
  float fitnessComparison = 100000000; // 3.402823466e+38F
  for (uint i = 0; i < SWARM_SIZE; i++)
  {
    if (gsLocalBestAndFitness[i].w < fitnessComparison)
    {
      indexToBest = i;
      fitnessComparison = gsLocalBestAndFitness[i].w;
    }
  }
  
  return indexToBest;
}

inline float IsPositiveAsFloat(float x)
{
  return (float) (x > 0);
}

inline float IsZeroOrNegativeAsFloat(float x)
{
  return (float) (x <= 0);
}

inline bool IsPositive(float x)
{
  return (x > 0);
}

//Returns a random normal distributed (mean 0, stdev 1) variable via Box-Muller-Transformation
//u1 and u2 should be uniform(0,1] random
inline float NormDist_0_1(float u1, float u2)
{
    return sqrt(-2.0 * log(u1)) * sin(2.0 * 3.14159265f * u2);
}

#ifdef SLAVE_OR_MASTER

RWStructuredBuffer<uint> RWSwarmIndexBuffer;
RWBuffer<uint> RWIndirectDispatchBuffer;

groupshared uint gsParticlesAlive;

#ifdef MASTER_SIM
groupshared float4 gsSlaveGlobalBestAndFitness;
#endif

void Simulate(uint swarmBufferIndex, uint particleBufferIndex, uint groupIndex)
{  
  SwarmData swarm = SwarmBuffer[swarmBufferIndex];
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
  
  /* ### START Update Particles life here
   * Collision handling etc.
   */
  
  //DEBUG Only
  if (groupIndex < 32 && particle.fitness < 20.0f)
    particle.health = 0.0*particle.health;
  
  /*
   * ### END 
   */
  
  bool isAlive = IsPositive(particle.health); // 1 when alive, 0 when dead
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead
  
#ifdef SLAVE_SIM
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  // Update velocity
  particle.velocity = inertiaWeight * particle.velocity 
    + (rand.x * c1) * (particle.localBest - particle.position) //In Richtung Local Best
    + (rand.y * c2) * (swarm.globalBest - particle.position); //In Richtung Global best
#endif
#ifdef MASTER_SIM
  if (groupIndex == 0)
  {
    float fitnessComparison = 100000000; // 3.402823466e+38F
    uint indexToBest = 0;
      //iterate slave swarms and determine globalBest 
    for (uint i = 0; i < RWIndirectDispatchBuffer[0]; i++)
    {
      uint slaveSwarmBufferIndex = SwarmIndexBuffer[i];
      SwarmData slaveSwarm = SwarmBuffer[slaveSwarmBufferIndex];
      
      if (IsPositive(slaveSwarm.particlesAlive) && slaveSwarm.fitness < fitnessComparison)
      {
        indexToBest = slaveSwarmBufferIndex;
        fitnessComparison = slaveSwarm.fitness;
      }
    }
    
      //Write global Best in sharedmemory
    gsSlaveGlobalBestAndFitness.xyz = SwarmBuffer[indexToBest].globalBest;
    gsSlaveGlobalBestAndFitness.w = SwarmBuffer[indexToBest].fitness;
  }
  
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  // Update velocity
  particle.velocity = inertiaWeight * particle.velocity 
    + (rand.x * c1) * (particle.localBest - particle.position)
    + (rand.y * c2) * (swarm.globalBest - particle.position)
    + (rand.z * c3) * (gsSlaveGlobalBestAndFitness.xyz - particle.position);
#endif
  
  // Handle Particles that are dead by multiplying their velocity with zero
  particle.velocity *= aliveMultiplicator;
  
  // Update position
  particle.velocity = sign(particle.velocity) * min(abs(particle.velocity), maxVelocity);
  particle.position += particle.velocity;

  // Apply boundary corrections
  // TODO: Make this more performant
  if (any(particle.position < worldmin))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = max(particle.position, worldmin) + rand * alpha;
  }
  if (any(particle.position > worldmax))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = min(particle.position, worldmax) - rand * alpha;
  }
  
  // Update fitness
  // Fitness is evaluated in terms of quadratic distance to target.
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  //If particle is dead add big handicap to fitness, so it doesn't get chosen a best.
  
  // Save localBest and fitness, if it's a new optimal local solution
  particle.localBest = (currentFitness < particle.fitness) ? particle.position : particle.localBest;
  particle.fitness = min(particle.fitness, currentFitness);
  
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  gsParticlesAlive = 0;
  
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  InterlockedOr(gsParticlesAlive, uint(isAlive));
  
  if (groupIndex == 0)
  {
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
  }
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  //DEBUG
  //particle.position = float(particleBufferIndex) / 2048.0 * float3(100, 100, 100) * rand;
  //#ifdef MASTER_SIM
  //particle.position = gsSlaveGlobalBestAndFitness.xyz;
  //#endif 
  
  /*
  TODO: Testen Evolutionary part
  */
    if (isAlive)// Only create replicas if current particle isnt dead
    {    
        //Replicate current particle N times and select its best replica
        SwarmParticleData best_replica = particle;
        for (uint i = 0; i < n; i++)
        {
            SwarmParticleData replica = particle;
            //create random variables [0,1] for all mutations and velocity equations
            float4 rand_mc = hash43(float3(particleBufferIndex, timeSinceStart, i + 0.6f));
            float2 rand_mw = hash22(float2(rand_mc.x, timeSinceStart));
            float2 rand_mbg = hash23(float3(rand_mc.yz, i + 1.22f));
            float3 rand_mutation = hash33(float3(rand_mbg, i + 23.2f));
        
            //calculate mutations
            float mw = inertiaWeight + (1 + sigma * NormDist_0_1(rand_mw.x, rand_mw.y)); // Equation 7
            float mc1 = c1 + (1 + sigma * NormDist_0_1(rand_mc.x, rand_mc.y));; // Equation 8
            float mc2 = c2 + (1 + sigma * NormDist_0_1(rand_mc.z, rand_mc.w));; // Equation 9
            float3 mbg = swarm.globalBest + (1 + sigma_g * NormDist_0_1(rand_mbg.x, rand_mbg.y));; // Equation 10. mutation global best
        
            #ifdef SLAVE_SIM
            //update velocity slave swarm. Equation 11
            replica.velocity = mw * replica.velocity 
            + (rand_mutation.x * mc1) * (replica.localBest - replica.position)
            + (rand_mutation.y * mc2) * (mbg - replica.position);
            #endif 
        
            #ifdef MASTER_SIM
            float2 rand_mc3 = hash22(float2(particleBufferIndex, rand_mc.w));
            float mc3 = c3 + (1 + sigma * NormDist_0_1(rand_mc3.x, rand_mc3.y));; // Equation 14
        
            //update velocity master swarm. Equation 12
            replica.velocity = mw * replica.velocity 
            + (rand_mutation.x * mc1) * (replica.localBest - replica.position)
            + (rand_mutation.y * mc2) * (mbg - replica.position)
            + (rand_mutation.z * mc3) * (gsSlaveGlobalBestAndFitness.xyz - replica.position);
            #endif
            //make shure we are slower than our max Velocity
            replica.velocity = sign(replica.velocity) * min(abs(replica.velocity), maxVelocity);
            
            //update position. Equation 2
            replica.position += replica.velocity;
        
            // Apply boundary corrections. Equation 4 & 5
            // TODO: Make this more performant
            if (any(replica.position < worldmin))
            {
                replica.velocity = -replica.velocity * rand_mutation.x;
                replica.position = max(replica.position, worldmin) + rand_mutation * alpha;
            }
            
            {
                replica.velocity = -replica.velocity * rand_mutation.x;
                replica.position = min(replica.position, worldmax) - rand_mutation * alpha;
            }
  
            // Update fitness
            // Fitness is evaluated in terms of quadratic distance to target.
            float currentFitness = length(replica.position - target);
  
            // Save localBest and fitness, if it's a new optimal local solution
            replica.localBest = (currentFitness < replica.fitness) ? replica.position : replica.localBest;
            replica.fitness = min(replica.fitness, currentFitness);
            
            //If we have a new best replica we save it
            best_replica = (replica.fitness < best_replica.fitness) ? replica : best_replica;
        }
         // Update original particles local best with the best replica
        particle.localBest = (best_replica.fitness < particle.fitness) ? best_replica.localBest : particle.localBest;
        particle.fitness = min(particle.fitness, best_replica.fitness);
  
        gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
    }
    //TODO: Sinnvoll mit if(isAlive)? Hier muss sowieso auf alle Threads gewartet werden für global best. Sync muss auch außerhalb von if() liegen,
    //da es sonst eventuell nicht erreicht wird von Threads
    GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();
  
    if (groupIndex == 0)//update global best of swarm
    {
        uint indexToBest = GetGSLocalBestIndex();
        swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
        swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
    }
    
    // Write results
    SwarmParticleBuffer[particleBufferIndex] = particle;
  
    if (groupIndex == 0)
    {
        swarm.particlesAlive = (gsParticlesAlive == 1);
        SwarmBuffer[swarmBufferIndex] = swarm; // Write result
    
    //TODO:
    //If no particles are alive, reduce number of threadgroups by 1
    //if particles are alive, increase number of threadgroups by 1
    //Also update index buffer, either move this to new compute kernel or do on CPU?
    //InterlockedAdd(RWIndirectDispatchBuffer[0], (gsParticlesAlive == 1) ? 0 : -1);
    }

}
#endif

#ifdef SLAVE_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void SlaveUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef MASTER_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void MasterUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{

  uint swarmBufferIndex = SwarmIndexBuffer[swarmBufferMasterIndex];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef SETUP_ONLY
[numthreads(SWARM_SIZE, 1, 1)]
void MaskedReset(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  //Initialize the population
  SwarmParticleData particle;
  if (reviveParticles)
    particle.health = MAX_HEALTH;
  else
    particle.health = SwarmParticleBuffer[particleBufferIndex].health;
  
  if (enablePositionReset)
    particle.position = resetPosition.xyz + rand * velocityVariance;
  else
    particle.position = SwarmParticleBuffer[particleBufferIndex].position;

  if (enableVelocityReset)
    particle.velocity = rand * velocityVariance;
  else
    particle.velocity = SwarmParticleBuffer[particleBufferIndex].velocity;
  
  
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead

  //Init fitness
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  particle.localBest = particle.position;
  particle.fitness = currentFitness;

  // Write results
  SwarmParticleBuffer[particleBufferIndex] = particle;
  
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  if (groupIndex == 0)
  {
    SwarmData swarm;
    
    if (reviveParticles)
      swarm.particlesAlive = true;
    else
      swarm.particlesAlive = SwarmBuffer[swarmBufferIndex].particlesAlive;
    
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
    
    SwarmBuffer[swarmBufferIndex] = swarm; // Write result
  }

}
#endif