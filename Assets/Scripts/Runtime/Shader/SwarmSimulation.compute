//Kernels with Definitions to allow different compilation per Kernel
#pragma kernel MaskedReset SETUP_ONLY
#pragma kernel SlaveUpdate SLAVE_SIM SLAVE_OR_MASTER
#pragma kernel MasterUpdate MASTER_SIM SLAVE_OR_MASTER

// Macro for HLSL Tools only for Visual Studio
// Prevents graying out unknown preprocessor macros
#if defined(__INTELLISENSE__)
  #define SETUP_ONLY
  #define SLAVE_SIM 
  #define MASTER_SIM
  #define SLAVE_OR_MASTER
#endif

#define SWARM_SIZE 64
#define MAX_HEALTH 1

#include "Definitions/Structs.hlsl"
#include "Utils/Random.hlsl"
#include "Definitions/SharedInputs.hlsl"
#include "Definitions/SimulationInputs.hlsl"

StructuredBuffer<uint> SwarmIndexBuffer;
RWStructuredBuffer<SwarmData> SwarmBuffer;
RWStructuredBuffer<SwarmParticleData> SwarmParticleBuffer;

// Shared Memory
groupshared float4 gsLocalBestAndFitness[SWARM_SIZE];

inline uint GetGSLocalBestIndex()
{
  uint indexToBest = 0;
  float fitnessComparison = 100000000; // 3.402823466e+38F
  for (uint i = 0; i < SWARM_SIZE; i++)
  {
    if (gsLocalBestAndFitness[i].w < fitnessComparison)
    {
      indexToBest = i;
      fitnessComparison = gsLocalBestAndFitness[i].w;
    }
  }
  return indexToBest;
}

inline float IsPositiveAsFloat(float x)
{
  return (float) (x > 0);
}
inline float IsZeroOrNegativeAsFloat(float x)
{
  return (float) (x <= 0);
}
inline bool IsPositive(float x)
{
  return (x > 0);
}

#ifdef SLAVE_OR_MASTER
RWStructuredBuffer<uint> RWSwarmIndexBuffer;
RWStructuredBuffer<uint> SwarmCounterBuffer;

groupshared uint gsParticlesAlive;
#ifdef MASTER_SIM
groupshared float4 gsSlaveGlobalBestAndFitness;
int numberOfSwarmsToRevive;
#endif

void Simulate(uint swarmBufferIndex, uint particleBufferIndex, uint groupIndex)
{
  /* -----------------------------------------------------------------------
   * TODO List
   * -----------------------------------------------------------------------
   *  - Evolutionary part nicht implementiert
   */
  
  // Read Swarm and Particle Data from Buffers
  SwarmData swarm = SwarmBuffer[swarmBufferIndex];
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
  // Get random values.
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  
  /* -----------------------------------------------------------------------
   * Particle Health Update
   * -----------------------------------------------------------------------
   *  - TODO: Collision handling etc.
   */
  
  //DEBUG Only
  if (particle.fitness > 50.0)
    particle.health -= 0.001;
  else 
    particle.health += 0.001;
  
  bool isAlive = IsPositive(particle.health); // 1 when alive, 0 when dead
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead
  
  /* -----------------------------------------------------------------------
   * Particle Velocity Update
   * -----------------------------------------------------------------------
   *  - TODO: Forces based due to obstacle avoidance
   */
  
  // Normalize but prevent NaN
  float3 dirToLocalBest = (particle.localBest - particle.position);
  dirToLocalBest = any(dirToLocalBest != 0) ? normalize(dirToLocalBest) : 0;
  float3 dirToGlobalBest = (swarm.globalBest - particle.position);
  dirToGlobalBest = any(dirToGlobalBest != 0) ? normalize(dirToGlobalBest) : 0;
  
#ifdef SLAVE_SIM
  particle.velocity = inertiaWeight * particle.velocity
    + (rand.x * c1) * dirToLocalBest //In Richtung Local Best
    + (rand.y * c2) * dirToGlobalBest; //In Richtung Global best
#endif
#ifdef MASTER_SIM
  // Velocity Update of master needs the globalBest of all swarms
  if (groupIndex == 0)
  {
    // Find best globalBest of all swarms
    float fitnessComparison = 100000000; // 3.402823466e+38F
    uint indexToBest = 0;
      //iterate slave swarms and determine globalBest 
    for (uint i = 0; i < SwarmCounterBuffer.Load(0); i++)
    {
      uint slaveSwarmBufferIndex = SwarmIndexBuffer[i];
      SwarmData slaveSwarm = SwarmBuffer[slaveSwarmBufferIndex];
      
      if (IsPositive(slaveSwarm.particlesAlive) && slaveSwarm.fitness < fitnessComparison)
      {
        indexToBest = slaveSwarmBufferIndex;
        fitnessComparison = slaveSwarm.fitness;
      }
    }
    
    //Write global Best in sharedmemory
    gsSlaveGlobalBestAndFitness.xyz = SwarmBuffer[indexToBest].globalBest;
    gsSlaveGlobalBestAndFitness.w = SwarmBuffer[indexToBest].fitness;
  }
  GroupMemoryBarrierWithGroupSync();
  
  
  float3 dirToSlaveGlobalBest = (gsSlaveGlobalBestAndFitness.xyz - particle.position);
  dirToSlaveGlobalBest = any(dirToSlaveGlobalBest != 0) ? normalize(dirToSlaveGlobalBest) : 0;
  
  particle.velocity = inertiaWeight * particle.velocity
    + (rand.x * c1) * dirToLocalBest
    + (rand.y * c2) * dirToGlobalBest
    + (rand.z * c3) * dirToSlaveGlobalBest;
#endif
  
  // Limit new velocity to maxVelocity and restore original sign.
  //particle.velocity += inertVelocity;
  //particle.velocity = sign(particle.velocity) * min(abs(particle.velocity), maxVelocity);
  // Handle Particles that are dead by multiplying their velocity with zero
  particle.velocity *= aliveMultiplicator;
  
  /* -----------------------------------------------------------------------
   * Particle Position Update and Boundary Correction
   * -----------------------------------------------------------------------
   *  - TODO: Maybe find a more non-thread-divergent solution
   */
  
  // Update position
  particle.position += particle.velocity;

  // Apply boundary corrections
  if (any(particle.position < worldmin))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = max(particle.position, worldmin) + rand * alpha;
  }
  if (any(particle.position > worldmax))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = min(particle.position, worldmax) - rand * alpha;
  }
  
  /* -----------------------------------------------------------------------
   * Particle Fitness and LocalBest Update
   * -----------------------------------------------------------------------
   *  - Fitness is evaluated in terms of distance to target.
   */
  
  // If particle is dead add big handicap to fitness, so it doesn't get chosen a best.
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  
  // Save localBest and fitness, if it's a new optimal local solution
  particle.localBest = (currentFitness < particle.fitness) ? particle.position : particle.localBest;
  particle.fitness = min(particle.fitness, currentFitness);
  
  /* -----------------------------------------------------------------------
   * Swarm Fitness, GlobalBest and ParticlesAlive Update
   * -----------------------------------------------------------------------
   *   - Utilizes GroupShared Memory to find the best solution for this swarm
   */
  
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  gsParticlesAlive = 0; //Init ParticlesAlive to 0 (RaceCondition warning, but no problem)
  
  GroupMemoryBarrierWithGroupSync();

  InterlockedAdd(gsParticlesAlive, uint(isAlive)); //Count Alive Particles
  
  if (groupIndex == 0)
  {
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
  }
  GroupMemoryBarrierWithGroupSync();

  //DEBUG
  //particle.position = float(particleBufferIndex) / 2048.0 * float3(100, 100, 100) * rand;
  //#ifdef MASTER_SIM
  //particle.position = gsSlaveGlobalBestAndFitness.xyz;
  //#endif
  
  /* -----------------------------------------------------------------------
   * Write results back to buffer
   * -----------------------------------------------------------------------
   * 
   */
  
  SwarmParticleBuffer[particleBufferIndex] = particle; // Update ParticleData
  
  if (groupIndex == 0) //Only groupIndex 0 writes SwarmData back to buffer
  {
    swarm.particlesAlive = gsParticlesAlive;
    SwarmBuffer[swarmBufferIndex] = swarm; // Update SwarmData
    
#ifdef SLAVE_SIM
    /* ---------------------------------------------------------------------
     * Update IndexBuffer and InvocationCount of next frames dispatch
     * ---------------------------------------------------------------------
     *  - This basically removes dead SlaveSwarms from being processed.
     */
    
    //If any particles are alive, increment counter to rebuild indexBuffer
    if (swarm.particlesAlive > 0)
    {
      // The counterBuffers value is used as the number of threadGroupsX next simulation step.
      uint index = SwarmCounterBuffer.IncrementCounter(); //Increments counter, index holds the pre-incremented counter value.
      RWSwarmIndexBuffer[index] = swarmBufferIndex; // Update Index
    }
#endif
    
#ifdef MASTER_SIM
    /* ---------------------------------------------------------------------
     * SlaveSwarm Reactivation
     * ---------------------------------------------------------------------
     *  - This basically re-adds SlaveSwarms to being processsed.
     *  - Remark: MasterSwarm Simulation is always run after Slave Simulation, so the InvocationCount representing all living swarms for next frame is available in SwarmCounterBuffer. We can now add more swarms, say reactivate them, by increasing this InvocationCount but respecting the max number of slave swarms allowed.
     *  - Remark: MasterSwarm Simulation may be followed by a MaskedReset call which is able to heal all active swarms. By increasing the InvocationCount here and afterwards healing all active swarms, we "revive" SlaveSwarms. MasterSwarm is always processed, even if all its particles are dead.
     *  - Remark: swarmBufferMasterIndex is equal to maxSlaveSwarmCount
     *            The numberOfSwarmsToRevive is determined on CPU as part of the "AI" behaviour
     *  - Warning: This is quite heavy code for GPU, but it's only done once per Swarm and frame, so we take it.
     */

    int swarmsLeftToRevive = numberOfSwarmsToRevive;
    // Iterate all SlaveSwarms and reactive them. Reactive as much as possible, stop if we iterated all swarms or if we revived enough.
    for (uint k = 0; (k < swarmBufferMasterIndex) && (swarmsLeftToRevive > 0); k++)
    {
      // Find a dead swarm
      if (SwarmBuffer[k].particlesAlive == 0)
      {
        uint index = SwarmCounterBuffer.IncrementCounter();
        RWSwarmIndexBuffer[index] = k;
        swarmsLeftToRevive--;
      }

    }
#endif
    
  }

  /*
  TODO: Add Evolutionary Part
  */
}
#endif

#ifdef SLAVE_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void SlaveUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef MASTER_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void MasterUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{

  uint swarmBufferIndex = SwarmIndexBuffer[swarmBufferMasterIndex];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef SETUP_ONLY
[numthreads(SWARM_SIZE, 1, 1)]
void MaskedReset(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  
  /* -----------------------------------------------------------------------
   * Conditional Update of particle data
   * -----------------------------------------------------------------------
   */
  bool particleWasRevived = false;
  if (reviveParticles)
  {
    // If particle was dead, set bool that is was revived
    particleWasRevived = (SwarmParticleBuffer[particleBufferIndex].health <= 0.0);
    particle.health = MAX_HEALTH;
  }
  
  if (enablePositionReset && ((resetOnlyIfRevived && particleWasRevived) || !resetOnlyIfRevived))
  {
    //Reset position if position reset is enabled AND particle was either revived or should be reset regardless
    particle.position = resetPosition.xyz + rand * velocityVariance;
  }
  
  if (enableVelocityReset && ((resetOnlyIfRevived && particleWasRevived) || !resetOnlyIfRevived))
  {
    //Reset velocity if velocity reset is enabled AND particle was either revived or should be reset regardless
    particle.velocity = rand * velocityVariance;
  }
  
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead

  /* -----------------------------------------------------------------------
   * Update/Init particle fitness
   * -----------------------------------------------------------------------
   */
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  particle.localBest = particle.position;
  particle.fitness = currentFitness;

  /* -----------------------------------------------------------------------
   * Swarm Fitness, GlobalBest and ParticlesAlive Update
   * -----------------------------------------------------------------------
   */
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  
  GroupMemoryBarrierWithGroupSync();

  if (groupIndex == 0)
  {
    SwarmData swarm = SwarmBuffer[swarmBufferIndex];
    
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
    
    // Update particles alive
    if (reviveParticles)
      swarm.particlesAlive = SWARM_SIZE;
    
    SwarmBuffer[swarmBufferIndex] = swarm; // Write result
  }
  
  /* -----------------------------------------------------------------------
   * Write particleData back to buffer
   * -----------------------------------------------------------------------
   */
  SwarmParticleBuffer[particleBufferIndex] = particle;
}
#endif