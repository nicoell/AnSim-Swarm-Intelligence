//Kernels with Definitions to allow different compilation per Kernel
#pragma kernel MaskedReset SETUP_ONLY
#pragma kernel SlaveUpdate SLAVE_SIM SLAVE_OR_MASTER
#pragma kernel MasterUpdate MASTER_SIM SLAVE_OR_MASTER

// Macro for HLSL Tools only for Visual Studio
// Prevents graying out unknown preprocessor macros
#if defined(__INTELLISENSE__)
  #define SETUP_ONLY
  //#define SLAVE_SIM 
  #define MASTER_SIM
  #define SLAVE_OR_MASTER
#endif

#define SWARM_SIZE 64
#define MAX_HEALTH 1

#include "Definitions/Structs.hlsl"
#include "Utils/Random.hlsl"
#include "Definitions/SharedInputs.hlsl"
#include "Definitions/SimulationInputs.hlsl"

// Forward declaration of functions, put them at end of file
uint GetGSLocalBestIndex();
float IsPositiveAsFloat(float x);
float IsZeroOrNegativeAsFloat(float x);
bool IsPositive(float x);
float NormDist_0_1(float u1, float u2);

StructuredBuffer<uint> SwarmIndexBuffer;
RWStructuredBuffer<SwarmData> SwarmBuffer;
RWStructuredBuffer<SwarmParticleData> SwarmParticleBuffer;

// Shared Memory
groupshared float4 gsLocalBestAndFitness[SWARM_SIZE];

#ifdef SLAVE_OR_MASTER
RWStructuredBuffer<uint> RWSwarmIndexBuffer;
RWStructuredBuffer<uint> SwarmCounterBuffer;

groupshared uint gsIndexToGlobalBest;
groupshared uint gsParticlesAlive;

#ifdef MASTER_SIM
groupshared float4 gsSlaveGlobalBestAndFitness;
int numberOfSwarmsToRevive;
#endif

void Simulate(uint swarmBufferIndex, uint particleBufferIndex, uint groupIndex)
{
  // Read Swarm and Particle Data from Buffers
  SwarmData swarm = SwarmBuffer[swarmBufferIndex];
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
  // Get random values.
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  
  /* -----------------------------------------------------------------------
   * Particle Health Update
   * -----------------------------------------------------------------------
   *  - TODO: Collision handling etc.
   */
  
  //DEBUG Only
  if (particle.fitness > 500.0)
    particle.health -= 0.0005;
  else
    particle.health += 0.0005;
  
  bool isAlive = IsPositive(particle.health); // 1 when alive, 0 when dead
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead
  
  /* -----------------------------------------------------------------------
   * Particle Velocity Update
   * -----------------------------------------------------------------------
   *  - TODO: Forces based due to obstacle avoidance
   */
  
  // Normalize but prevent NaN
  float3 dirToLocalBest = (particle.localBest - particle.position);
  dirToLocalBest = any(dirToLocalBest != 0) ? normalize(dirToLocalBest) : 0;
  float3 dirToGlobalBest = (swarm.globalBest - particle.position);
  dirToGlobalBest = any(dirToGlobalBest != 0) ? normalize(dirToGlobalBest) : 0;
  
#ifdef SLAVE_SIM
  particle.velocity = inertiaWeight * particle.velocity
    + (rand.x * c1) * dirToLocalBest //In Richtung Local Best
    + (rand.y * c2) * dirToGlobalBest; //In Richtung Global best
#endif
#ifdef MASTER_SIM
  // Velocity Update of master needs the globalBest of all swarms
  if (groupIndex == 0)
  {
    // Find best globalBest of all swarms
    float fitnessComparison = 100000000; // 3.402823466e+38F
    uint indexToBest = 0;
    //iterate slave swarms and determine globalBest 
    for (uint i = 0; i < SwarmCounterBuffer.Load(0); i++)
    {
      uint slaveSwarmBufferIndex = SwarmIndexBuffer[i];
      SwarmData slaveSwarm = SwarmBuffer[slaveSwarmBufferIndex];
      
      //Check if swarm is alive and compare fitness
      if (IsPositive(slaveSwarm.particlesAlive) && slaveSwarm.fitness < fitnessComparison)
      {
        indexToBest = slaveSwarmBufferIndex;
        fitnessComparison = slaveSwarm.fitness;
      }
    }
    
    //Write global Best in sharedmemory
    gsSlaveGlobalBestAndFitness.xyz = SwarmBuffer[indexToBest].globalBest;
    gsSlaveGlobalBestAndFitness.w = SwarmBuffer[indexToBest].fitness;
  }
  GroupMemoryBarrierWithGroupSync();
  
  // Normalize but prevent NaN
  float3 dirToSlaveGlobalBest = (gsSlaveGlobalBestAndFitness.xyz - particle.position);
  dirToSlaveGlobalBest = any(dirToSlaveGlobalBest != 0) ? normalize(dirToSlaveGlobalBest) : 0;
  
  particle.velocity = inertiaWeight * particle.velocity
    + (rand.x * c1) * dirToLocalBest
    + (rand.y * c2) * dirToGlobalBest
    + (rand.z * c3) * dirToSlaveGlobalBest;
#endif
  
  // Limit new velocity to maxVelocity and restore original sign.
  //particle.velocity += inertVelocity;
  //particle.velocity = sign(particle.velocity) * min(abs(particle.velocity), maxVelocity);
  // Handle Particles that are dead by multiplying their velocity with zero
  particle.velocity *= aliveMultiplicator;
  
  /* -----------------------------------------------------------------------
   * Particle Position Update and Boundary Correction
   * -----------------------------------------------------------------------
   *  - TODO: Maybe find a more non-thread-divergent solution
   */
  
  // Update position
  particle.position += particle.velocity;

  // Apply boundary corrections
  if (any(particle.position < worldmin))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = max(particle.position, worldmin) + rand * alpha;
  }
  if (any(particle.position > worldmax))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = min(particle.position, worldmax) - rand * alpha;
  }
  
  /* -----------------------------------------------------------------------
   * Particle Fitness and LocalBest Update
   * -----------------------------------------------------------------------
   *  - Fitness is evaluated in terms of distance to target.
   */
  
  // If particle is dead add big handicap to fitness, so it doesn't get chosen a best.
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  
  // Save localBest and fitness, if it's a new optimal local solution
  particle.localBest = (currentFitness < particle.fitness) ? particle.position : particle.localBest;
  particle.fitness = min(particle.fitness, currentFitness);
  
  /* -----------------------------------------------------------------------
   * Swarm Fitness, GlobalBest and ParticlesAlive Update
   * -----------------------------------------------------------------------
   *   - Utilizes GroupShared Memory to find the best solution for this swarm
   */
  
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  gsParticlesAlive = 0; //Init ParticlesAlive to 0 (RaceCondition warning, but no problem)
  
  GroupMemoryBarrierWithGroupSync();

  InterlockedAdd(gsParticlesAlive, uint(isAlive)); //Count Alive Particles
  
  if (groupIndex == 0)
  {
    uint indexToBest = GetGSLocalBestIndex();
    // Only save index to SharedMemory global Best so everyone can use it.
    // Writing results back to swarm Struct is only visible for groupIndex = 0
    gsIndexToGlobalBest = indexToBest; 
    //swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    //swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
  }
  GroupMemoryBarrierWithGroupSync();
    
  /* -----------------------------------------------------------------------
   * Evolutionary Part 
   * -----------------------------------------------------------------------
   *   - Replicates original particle N times and mutates each replica to find
   *     a better local best for original particle
   *   - Uses the in this iteration already updated swarms global best and particles local best
   */
  
  if (isAlive)// Only create replicas if current particle isnt dead
  {
    //Replicate current particle N times and select its best replica
    SwarmParticleData best_replica = particle;
    for (uint i = 0; i < n; i++)
    {
      SwarmParticleData replica = particle;
      //create random variables [0,1] for all mutations and velocity equations
      float4 rand_mc = hash43(float3(particleBufferIndex, timeSinceStart, i + 0.6f));
      float2 rand_mw = hash22(float2(rand_mc.x, timeSinceStart));
      float2 rand_mbg = hash23(float3(rand_mc.yz, i + 1.22f));
      float3 rand_mutation = hash33(float3(rand_mbg, i + 23.2f));
        
      //calculate mutations
      float mw = inertiaWeight + (1 + sigma * NormDist_0_1(rand_mw.x, rand_mw.y)); // Equation 7
      float mc1 = c1 + (1 + sigma * NormDist_0_1(rand_mc.x, rand_mc.y));; // Equation 8
      float mc2 = c2 + (1 + sigma * NormDist_0_1(rand_mc.z, rand_mc.w));; // Equation 9
      float3 mbg = gsLocalBestAndFitness[gsIndexToGlobalBest].xyz + (1 + sigma_g * NormDist_0_1(rand_mbg.x, rand_mbg.y));; // Equation 10. mutation global best
        
      // Normalize but prevent NaN
      float3 dirToLocalBest = (replica.localBest - replica.position);
      dirToLocalBest = any(dirToLocalBest != 0) ? normalize(dirToLocalBest) : 0;
      float3 dirToGlobalBest = (mbg - replica.position);
      dirToGlobalBest = any(dirToGlobalBest != 0) ? normalize(dirToGlobalBest) : 0;
#ifdef SLAVE_SIM
            //update velocity slave swarm. Equation 11
            replica.velocity = mw * replica.velocity 
            + (rand_mutation.x * mc1) * dirToLocalBest
            + (rand_mutation.y * mc2) * dirToGlobalBest;
#endif        
#ifdef MASTER_SIM
      float2 rand_mc3 = hash22(float2(particleBufferIndex, rand_mc.w));
      float mc3 = c3 + (1 + sigma * NormDist_0_1(rand_mc3.x, rand_mc3.y));; // Equation 14
        
      // Normalize but prevent NaN
      float3 dirToSlaveGlobalBest = (gsSlaveGlobalBestAndFitness.xyz - replica.position);
      dirToSlaveGlobalBest = any(dirToSlaveGlobalBest != 0) ? normalize(dirToSlaveGlobalBest) : 0;
      
      // Update velocity master swarm. Equation 12
      replica.velocity = mw * replica.velocity 
            + (rand_mutation.x * mc1) * dirToLocalBest
            + (rand_mutation.y * mc2) * dirToGlobalBest
            + (rand_mutation.z * mc3) * dirToSlaveGlobalBest;
#endif            
      // Update position. Equation 2
      replica.position += replica.velocity;
        
      // Apply boundary corrections. Equation 4 & 5
      if (any(replica.position < worldmin))
      {
        replica.velocity = -replica.velocity * rand_mutation.x;
        replica.position = max(replica.position, worldmin) + rand_mutation * alpha;
      }
      if (any(replica.position > worldmax))
      {
        replica.velocity = -replica.velocity * rand_mutation.x;
        replica.position = min(replica.position, worldmax) - rand_mutation * alpha;
      }
  
      // Update fitness
      // Fitness is evaluated in terms of quadratic distance to target.
      float currentFitness = length(replica.position - target);
  
      // Save localBest and fitness, if it's a new optimal local solution
      replica.localBest = (currentFitness < replica.fitness) ? replica.position : replica.localBest;
      replica.fitness = min(replica.fitness, currentFitness);
            
      //If we have a new best replica we save it
      if (replica.fitness < best_replica.fitness)
      {
        best_replica = replica;
      }
    }
    // Update original particles local best with the best replica
    particle.localBest = (best_replica.fitness < particle.fitness) ? best_replica.localBest : particle.localBest;
    particle.fitness = min(particle.fitness, best_replica.fitness);
  
    gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  }
    //TODO: Sinnvoll mit if(isAlive)? Hier muss sowieso auf alle Threads gewartet werden für global best. Sync muss auch außerhalb von if() liegen,
    //da es sonst eventuell nicht erreicht wird von Threads
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  /* -----------------------------------------------------------------------
   * Write results back to buffer
   * -----------------------------------------------------------------------
   * 
   */
  
  if (groupIndex == 0)//update global best of swarm
  {
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
  }
  
  SwarmParticleBuffer[particleBufferIndex] = particle; // Update ParticleData
  
  if (groupIndex == 0) //Only groupIndex 0 writes SwarmData back to buffer
  {
    swarm.particlesAlive = gsParticlesAlive;
    SwarmBuffer[swarmBufferIndex] = swarm; // Update SwarmData
    
#ifdef SLAVE_SIM
    /* ---------------------------------------------------------------------
     * Update IndexBuffer and InvocationCount of next frames dispatch
     * ---------------------------------------------------------------------
     *  - This basically removes dead SlaveSwarms from being processed.
     */
    
    //If any particles are alive, increment counter to rebuild indexBuffer
    if (swarm.particlesAlive > 0)
    {
      // The counterBuffers value is used as the number of threadGroupsX next simulation step.
      uint index = SwarmCounterBuffer.IncrementCounter(); //Increments counter, index holds the pre-incremented counter value.
      RWSwarmIndexBuffer[index] = swarmBufferIndex; // Update Index
    }
#endif
    
#ifdef MASTER_SIM
    /* ---------------------------------------------------------------------
     * SlaveSwarm Reactivation
     * ---------------------------------------------------------------------
     *  - This basically re-adds SlaveSwarms to being processsed.
     *  - Remark: MasterSwarm Simulation is always run after Slave Simulation, so the InvocationCount representing all living swarms for next frame is available in SwarmCounterBuffer. We can now add more swarms, say reactivate them, by increasing this InvocationCount but respecting the max number of slave swarms allowed.
     *  - Remark: MasterSwarm Simulation may be followed by a MaskedReset call which is able to heal all active swarms. By increasing the InvocationCount here and afterwards healing all active swarms, we "revive" SlaveSwarms. MasterSwarm is always processed, even if all its particles are dead.
     *  - Remark: swarmBufferMasterIndex is equal to maxSlaveSwarmCount
     *            The numberOfSwarmsToRevive is determined on CPU as part of the "AI" behaviour
     *  - Warning: This is quite heavy code for GPU, but it's only done once per Swarm and frame, so we take it.
     */

    int swarmsLeftToRevive = numberOfSwarmsToRevive;
    // Iterate all SlaveSwarms and reactive them. Reactive as much as possible, stop if we iterated all swarms or if we revived enough.
    for (uint k = 0; (k < swarmBufferMasterIndex) && (swarmsLeftToRevive > 0); k++)
    {
      // Find a dead swarm
      if (SwarmBuffer[k].particlesAlive == 0)
      {
        uint index = SwarmCounterBuffer.IncrementCounter();
        RWSwarmIndexBuffer[index] = k;
        swarmsLeftToRevive--;
      }

    }
#endif
    
  }
}
#endif

#ifdef SLAVE_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void SlaveUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef MASTER_SIM
[numthreads(SWARM_SIZE, 1, 1)]
void MasterUpdate(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{

  uint swarmBufferIndex = SwarmIndexBuffer[swarmBufferMasterIndex];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  Simulate(swarmBufferIndex, particleBufferIndex, groupIndex);
}
#endif

#ifdef SETUP_ONLY
[numthreads(SWARM_SIZE, 1, 1)]
void MaskedReset(uint3 group : SV_GroupID, uint groupIndex : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  uint swarmBufferIndex = SwarmIndexBuffer[group.x];
  uint particleBufferIndex = swarmBufferIndex * SWARM_SIZE + groupIndex;
  
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
  float3 rand = hash32(float2(particleBufferIndex, timeSinceStart));
  
  /* -----------------------------------------------------------------------
   * Conditional Update of particle data
   * -----------------------------------------------------------------------
   */
  bool particleWasRevived = false;
  if (reviveParticles)
  {
    // If particle was dead, set bool that is was revived
    particleWasRevived = (SwarmParticleBuffer[particleBufferIndex].health <= 0.0);
    particle.health = MAX_HEALTH;
  }
  
  if (enablePositionReset && ((resetOnlyIfRevived && particleWasRevived) || !resetOnlyIfRevived))
  {
    //Reset position if position reset is enabled AND particle was either revived or should be reset regardless
    particle.position = resetPosition.xyz + rand * velocityVariance;
  }
  
  if (enableVelocityReset && ((resetOnlyIfRevived && particleWasRevived) || !resetOnlyIfRevived))
  {
    //Reset velocity if velocity reset is enabled AND particle was either revived or should be reset regardless
    particle.velocity = rand * velocityVariance;
  }
  
  float aliveMultiplicator = IsPositiveAsFloat(particle.health); // 1 when alive, 0 when dead
  float deadMultiplicator = IsZeroOrNegativeAsFloat(particle.health); // 0 when alive, 1 when dead

  /* -----------------------------------------------------------------------
   * Update/Init particle fitness
   * -----------------------------------------------------------------------
   */
  float3 direction = particle.position - target;
  float currentFitness = length(direction) + deadMultiplicator * 1000000;
  particle.localBest = particle.position;
  particle.fitness = currentFitness;

  /* -----------------------------------------------------------------------
   * Swarm Fitness, GlobalBest and ParticlesAlive Update
   * -----------------------------------------------------------------------
   */
  gsLocalBestAndFitness[groupIndex] = float4(particle.localBest, particle.fitness);
  
  GroupMemoryBarrierWithGroupSync();

  if (groupIndex == 0)
  {
    SwarmData swarm = SwarmBuffer[swarmBufferIndex];
    
    uint indexToBest = GetGSLocalBestIndex();
    swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
    swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
    
    // Update particles alive
    if (reviveParticles)
      swarm.particlesAlive = SWARM_SIZE;
    
    SwarmBuffer[swarmBufferIndex] = swarm; // Write result
  }
  
  /* -----------------------------------------------------------------------
   * Write particleData back to buffer
   * -----------------------------------------------------------------------
   */
  SwarmParticleBuffer[particleBufferIndex] = particle;
}
#endif


/* -----------------------------------------------------------------------
 * Function declarations
 * -----------------------------------------------------------------------
 */
inline uint GetGSLocalBestIndex()
{
  uint indexToBest = 0;
  float fitnessComparison = 100000000; // 3.402823466e+38F
  for (uint i = 0; i < SWARM_SIZE; i++)
  {
    if (gsLocalBestAndFitness[i].w < fitnessComparison)
    {
      indexToBest = i;
      fitnessComparison = gsLocalBestAndFitness[i].w;
    }
  }
  return indexToBest;
}

inline float IsPositiveAsFloat(float x)
{
  return (float) (x > 0);
}
inline float IsZeroOrNegativeAsFloat(float x)
{
  return (float) (x <= 0);
}
inline bool IsPositive(float x)
{
  return (x > 0);
}

//Returns a random normal distributed (mean 0, stdev 1) variable via Box-Muller-Transformation
//u1 and u2 should be uniform(0,1] random
inline float NormDist_0_1(float u1, float u2)
{
  return sqrt(-2.0 * log(u1)) * sin(2.0 * 3.14159265f * u2);
}

