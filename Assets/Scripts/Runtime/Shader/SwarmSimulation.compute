//Kernels with Definitions to allow different compilation per Kernel
#pragma kernel Setup SETUP_ONLY
#pragma kernel SlaveUpdate SLAVE_SIM SLAVE_OR_MASTER
#pragma kernel MasterUpdate MASTER_SIM SLAVE_OR_MASTER

// Macro for HLSL Tools only for Visual Studio
// Prevents graying out unknown preprocessor macros
#if defined(__INTELLISENSE__)
  #define SETUP_ONLY
  #define SLAVE_SIM 
  #define MASTER_SIM
  #define SLAVE_OR_MASTER
#endif

//TODO: Should be equal because Setup iniates all particles using SLAVE_SWARM_SIZE
#define SLAVE_SWARM_SIZE 64
#define MASTER_SWARM_SIZE 64

#include "Definitions/Structs.hlsl"
#include "Utils/Random.hlsl"
#include "Definitions/SharedInputs.hlsl"
#include "Definitions/SimulationInputs.hlsl"

RWStructuredBuffer<SwarmParticleData> SwarmParticleBuffer;
RWStructuredBuffer<SwarmData> SwarmBuffer;

#ifdef SLAVE_OR_MASTER

// Shared Memory
groupshared float4 gsLocalBestAndFitness[SLAVE_SWARM_SIZE];

void Simulate(uint swarmBufferIndex, uint particleBufferIndex, uint group_index)
{
  /*
   - inertiaWeight wird nicht auf der CPU neu berechnet
   - Swarm Globalbest funktioniert so nicht
   - SlaveGlobalBest noch nicht, wird noch nicht berechnet
   - Evolutionary part nicht implementiert
  */
  
  SwarmData swarm = SwarmBuffer[swarmBufferIndex];
  SwarmParticleData particle = SwarmParticleBuffer[particleBufferIndex];
#ifdef SLAVE_SIM
  float3 rand = hash31(timeSinceStart);
  // Update velocity
  particle.velocity = inertiaWeight * particle.velocity 
    + rand.x * c1 * (particle.localBest - particle.position) //In Richtung Local Best
    + rand.y * c2 * (swarm.globalBest - particle.position); //In Richtung Global best
#endif
#ifdef MASTER_SIM
  //if (group_index == 0)
  //{
  //  //iterate slave swarm
  //  //determine globalBest 
  //}
  
  //GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  float3 rand = hash31(timeSinceStart);
  // Update velocity
  particle.velocity = inertiaWeight * particle.velocity 
    + rand.x * c1 * (particle.localBest - particle.position)
    + rand.y * c2 * (swarm.globalBest - particle.position)
    + rand.z * c3 * (slaveGlobalBest - particle.position);
#endif
  
  // Update position
  particle.position += particle.velocity;

  // Apply boundary corrections
  // TODO: Make this more performant
  if (any(particle.position < worldmin))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = max(particle.position, worldmin) + rand.y * alpha;
  }
  if (any(particle.position > worldmax))
  {
    particle.velocity = -particle.velocity * rand.x;
    particle.position = min(particle.position, worldmax) - rand.y * alpha;
  }
  
  // Update fitness
  // Fitness is evaluated in terms of quadratic distance to target.
  float3 direction = particle.position - target;
  float currentFitness = dot(direction, direction);
  
  // Save localBest and fitness, if it's a new optimal local solution
  particle.localBest = (currentFitness < particle.fitness) ? particle.position : particle.localBest;
  particle.fitness = min(particle.fitness, currentFitness);
  
  gsLocalBestAndFitness[group_index] = float4(particle.localBest, particle.fitness);
  
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();
  
  uint indexToBest = 0;
  if (group_index == 0)
  {
    for (uint i = 1; i < SLAVE_SWARM_SIZE; i++)
    {
      if (gsLocalBestAndFitness[i].w < particle.fitness)
      {
        indexToBest = i;
      }
    }
  }
  
  swarm.globalBest = gsLocalBestAndFitness[indexToBest].xyz;
  swarm.fitness = gsLocalBestAndFitness[indexToBest].w;
  
  GroupMemoryBarrierWithGroupSync(); //AllMemoryBarrierWithGroupSync();

  // Write results
  SwarmParticleBuffer[particleBufferIndex] = particle;
  
  // Write best group result only once per group.
  if (group_index == 0)
  {
    SwarmBuffer[swarmBufferIndex] = swarm; // 32 + 1
  }
  
  /*
  TODO: Add Evolutionary Part
  */
}
#endif

#ifdef SLAVE_SIM
[numthreads(SLAVE_SWARM_SIZE, 1, 1)]
void SlaveUpdate(uint3 group : SV_GroupID, uint group_index : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  Simulate(group.x, id.x, group_index);
}
#endif

#ifdef MASTER_SIM
[numthreads(MASTER_SWARM_SIZE, 1, 1)]
void MasterUpdate(uint3 group : SV_GroupID, uint group_index : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  Simulate(swarmBufferMasterIndex, swarmParticleBufferMasterOffset + id.x, group_index);
  //Simulate(swarmBufferMasterIndex, swarmBufferMasterIndex * 64 + id.x, group_index);
}
#endif

#ifdef SETUP_ONLY

[numthreads(SLAVE_SWARM_SIZE, 1, 1)]
void Setup(uint3 group : SV_GroupID, uint group_index : SV_GroupIndex, uint3 id : SV_DispatchThreadID)
{
  float3 rand = hash31(id.x * timeSinceStart);
  //Initialize the population
  SwarmParticleData particle;
  particle.position = startPosition.xyz + rand * positionVariance;
  particle.velocity = rand * velocityVariance;
  SwarmData swarm;
  
  //Init fitness
  particle.localBest = particle.position - target;
  particle.fitness = dot(particle.localBest, particle.localBest);

  // Write results
  SwarmParticleBuffer[id.x] = particle;
  
  // Write best group result only once per group.
  if (group_index == 0)
  {
    //TODO: For now just set swarms values as the first of group
    
    swarm.fitness = particle.fitness;
    swarm.globalBest = particle.localBest;
    
    SwarmBuffer[group.x] = swarm;
  }
}
#endif